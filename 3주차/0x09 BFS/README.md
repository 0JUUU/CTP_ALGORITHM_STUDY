## 0x09강 BFS👾

#### 0x00 알고리즘 설명
 [ BFS(Breadth First Search) : 다차원 배열에서 각 칸을 방문할 때 너비를 우선으로 방문하는 알고리즘 ] 

- 원래 BFS : 그래프라는 자료구조에서 모든 노드를 방문하기 위한 알고리즘 ( 그래프 : 정점과 간선으로 이루어진 자료구조)

#### 0x01 예시

목표 : (0, 0) 과 상하좌우로 이어진 모든 파란색 칸을 확인하는 것 👉 BFS 로 해결

---
##### BFS 알고리즘 : 좌표를 담을 큐 필요

시작 ) (0,0)에 방문했다는 표시, 해당 칸을 큐에 넣음 (초기 세팅)

초기 세팅이 끝난 후에는 큐가 빌 때까지 계속 큐의 front를 빼고 해당 좌표의 상하좌우를 살펴보면서 큐에 넣어주는 작업을 반복


큐의 front는 (0,0) 👉 pop을 함
(0,0)의 상하좌우 칸 확인 👉 파란색 칸이면서 아직 방문하지 않은 칸을 찾음


 (0,0)과 상하좌우로 인접한 (0,1)과 (1,0)은 모두 파란 칸이면서 아직 방문 X 👉 이 2개의 칸에 방문했다는 표시 & 큐에 넣음


(0,0) 작업은 완료 👉 다음으로 넘어감
현재 큐의 front는 (0,1) 👉 pop 
이번에도 (0,1)의 상하좌우 칸을 확인 : 이 칸들 중에서 (0,0)은 파란 칸이지만 이미 방문을 했고, (1,1)은 빨간 칸 / 유일하게 (0,2)만 파란색 칸이면서 아직 방문하지 않은 칸 👉 (0,2)에 방문했다는 표시 & 큐에 넣기


 계속 이런 식으로 큐의 front를 pop하고 인접한 칸 중에서 방문하지 않은 파란색 칸에 표시를 남기고 큐에 넣어주면 됨 


큐가 빈 순간 과정은 종료 👉 (0,0)과 상하좌우로 이어진 모든 파란 칸을 잘 방문했음을 확인

[과정 Step by step]
1. 시작하는 칸을 큐에 넣고 방문했다는 표시를 남김
2. 큐에서 원소를 꺼내어 그 칸에 상하좌우로 인접한 칸에 대해 3번 실행
3. 해당 칸을 이전에 방문했다면 아무 것도 하지 않고, 처음으로 방문했다면 방문했다는 표시를 남기고 해당 칸을 큐에 삽입
4. 큐가 빌 때까지 2번을 반복
: 모든 칸이 큐에 한 번씩 들어가므로 시간복잡도는 칸이 N개일 때, O(N) (만약 행 : R개, 열이 C개 👉 O(RC) )

[구현]
- utility 헤더에 있는 pair 
: pair를 이용하면 두 자료형을 묶어서 가지고 다닐 수 O 👉 make_pair로 값을 넣어줄 수도 있고, C++11 이상에서는 그냥 중괄호를 써서 쉽게 해결 가능

값의 접근은 각각 first, second를 부름으로서 가능 / pair에서는 미리 대소 관계 설정되어 있어 편함 👉 알아서 앞쪽의 값을 먼저 비교, 이후 뒤쪽의 값을 비교
BFS 구현 👉 큐에 좌표를 넣을 때 pair 사용

- BFS 구현 코드 : 외우고 있는 것이 좋음

[BFS 구현 시, 자주 실수하는 부분]
1. 시작점에 방문했다는 표시를 남기지 않음 👉 시작점을 두 번 방문할 수 있게 됨
2. 큐에 넣을 때 방문했다는 표시를 하는 대신 큐에서 뺄 때 방문했다는 표시를 남김 👉 같은 칸이 큐에 여러 번 들어가게 되어 시간 초과나 메모리 초과 발생 (예제로 주는 작은 케이스에서는 잘 돌아가다가 실제 제출을 했을 때 터지는 경우가 많기 때문에 주의)
3. 이웃한 원소가 범위를 벗어났는지에 대한 체크를 잘못함 👉 nx, ny가 배열 바깥으로 벗어났는지에 대한 루틴을 아예 빼먹었거나, 아니면 이상하게 구현을 한 상황

👉 BFS로 Flood Fill을 수행하는 것

#### 0x02 응용 1 – 거리 측정
방문했다는 표시 대신에 각 칸에 (0,0)까지의 거리를 적어줌
거리를 나타내는 배열을 사용 👉 visited 대신 사용 가능
 
#### 0x03 응용 2 – 시작점이 여러 개일 때 
모든 시작점을 큐에 넣고 시작

#### 0x04 응용 3 – 시작점이 두 종류일 때
하나를 BFS 먼저 돌리고, 이 후 두 번째 BFS 할 때 비교 연산

#### 0x05 응용 4 – 1차원에서의 BFS
이동 조건을 잘 세우면 접근하기 쉬움
● 범위 지정 : IF 예제 👉 당연히 수빈이가 0에서 100,000 사이에서만 움직인다고 멋대로 가정을 하고 풀면 X !!
(00,000 바깥으로 나갈 수 있겠지만 일단 한 번 나갔다면 그 이후로는 -1만 계속 함. 그렇기 때문에 동생을 가장 빠르게 찾아나가는 상황에서는 아무리 멀리가도 200,000을 넘어가지는 않습니다.)
