## 0x06강 큐  👾
#### 0x00 정의와 성질
[큐] <br>
한쪽 끝에서 원소를 넣고 반대쪽 끝에서 원소를 뺄 수 있는 자료구조
- 스택에서는 먼저 들어간 원소가 나중에 나왔는데 큐에서는 먼저 들어간 원소가 먼저 나오게 됨 👉 FIFO(First In First Out)

● 성질
기능|시간복잡도
---|:---:
원소의 추가 | O(1)
원소의 제거 | O(1)
제일 앞/뒤의 원소 확인 | O(1)
*제일 앞/뒤가 아닌 나머지 원소들의 확인/변경이 원칙적으로 불가능


: 큐에서는 추가되는 곳을 rear, 즉 뒤쪽이라고 하고 제거되는 쪽을 front, 즉 앞쪽이라고 함 <br>
- 큐 👉 인덱스를 가지고 원소에 접근하는 기능 X. 배열을 가지고 직접 만들 땐 해당 기능이 가능하도록 구현을 할 수는 O (단, STL queue에서는 인덱스로 내부 원소를 접근하는 기능 X)

#### 0x01 기능과 구현
구현
``` C++
cosnt int MX  1000005;
int dat[MX];
int head = 0, tail = 0;
```

: 큐 구현 시, 원소를 담을 큰 배열 한 개, 앞, 뒤쪽을 가리킬 변수 두 개가 필요

[이미지]

dat 배열에서 `dat[head]`부터 `dat[tail – 1]`번지가 큐의 원소들이 들어있는 자리 👉 크기 : `tail – head`

push를 할 땐 tail 증가 / pop 할 땐 head 증가 👉 dat 배열에서 큐의 원소들이 들어있는 장소는 점점 오른쪽으로 밀림

스택과 다르게 큐를 배열로 구현하면 삭제가 발생할 때마다 앞쪽에 쓸모없는 공간이 계속 생김 <br>
👉 해결 방법 : 큐의 원소가 들어갈 배열을 원형으로 만듦 
<br> ( 관념적으로는 배열이 원형인거고, 실제 구현 시, size가 8인 배열이라면 head나 tail이 7인 상태에서 1이 더해질 때 0번지로 다시 오도록 만듦) : 이렇게 원형의 배열을 가정하고 구현한 큐를 원형 큐(Circular Queue)라고 함

#### 0x02 STL queue
큐가 비어있는데 front / back / pop 호출 👉 런타임에러 발생
