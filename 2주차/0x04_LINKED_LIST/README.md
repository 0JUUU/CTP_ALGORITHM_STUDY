
## 0x04강 연결 리스트 👾
#### 0x00 정의와 성질
연결 리스트 : 원소들을 저장할 때 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조

성질
1. k번째 워소를 확인/변경 :  O(k)
2. 임의의 위치에 원소를 추가/제거 : O(1)
3. 원소들이 메모리 상에 연속해있지 않아 Cache hit rate가 낮지만 할당이 다소 쉬움

**[종류]**  
종류|정의
|:---|:---
단일 연결 리스트 (Singly Linked List) | 각 원소가 자신의 다음 원소의 주소를 들고 있는 연결 리스트  
이중 연결 리스트 (Doubly Linked List) | <ul> - 각 원소가 자신의 이전 원소와 다음 원소의 주소를 둘 다 지님 (👉 자신의 이전 원소가 무엇인지 알 수 있다는 장점)<br> - 단점 : 원소가 가지고 있어야 하는 정보가 1개 더 추가 👉 메모리를 더 씀 <br> - STL 연결 리스트 구조 : 이중 연결 리스트  </ul>
원형 연결 리스트 (Circular Linked LIst) | 끝이 처음과 연결

배열 VS 연결 리스트 <br> (배열과 리스트 모두 원소들 사이의 선후 관계가 일대일로 정의 👉 원소들 사이에서 첫 번째 원소, 두 번째 원소, ... 이런 개념이 존재) 👉 선형 자료구조


 　  | 배열 | 연결 리스트
| :------------ | :-----------: | :-------------------: |
k번째 원소의 접근 | O(1) | O(k)
임의의 위치에 원소 추가/제거 | O(N) | O(1)
메모리 상의 배치 | 연속 | 불연속
추가적으로 필요한 공간 (Overhead)| - | O(N)

 - 임의의 위치에 있는 원소를 확인/변경, O(N)
: 배열과 다르게 임의의 위치에 있는 원소로 가기 위해서는 그 위치에 도달할 때까지 첫 번째부터 순차적으로 방문해야 함(첫 번째 원소의 주소만 알고 있기 때문)

 - 임의의 위치에 원소를 추가, O(1)
: 어떤 원소 뒤에 다른 원소를 추가하고 싶다면, 어떤 원소와 추가하고자 하는 원소의 다음 원소의 주소만 변경하면 됨 👉 추가하고 싶은 위치의 주소를 알고 있을 때만 O(1)
IF 추가하고 싶은 원소를 세 번째 원소 뒤에 추가하라는 명령 : 세 번째 원소까지 찾아가야 하는 시간이 추가로 걸림

 - 임의 위치의 원소를 제거, O(1)

커서를 옮기고 글자를 지우는 것과 같은 연산들이 많은 문제는 배열보다 리스트가 효율적

연결 리스트의 구현

``` C++
struct NODE {
	struct NODE *prev, *next;
	int data;
};
```

야매 리스트 구현

``` C++
const int MX = 1000005;
int dat[MX], pre[MX], nxt[MX];
int unused = 1;

fill(pre, pre + MX, -1);
fill(nxt, nxt + MX, -1);
```

: 원소를 배열로 관리, pre와 nxt 이전/다음 원소의 포인터 대신 배열 상의 인덱스를 저장하는 방식으로 구현한 연결 리스트 <br>
- dat[i] : i번지 원소의 값
- pre[i] : i번지 원소에 대해 이전 원소의 인덱스
- nxt[i] : 다음 원소의 인덱스 (pre, nxt의 값이 –1 : 해당 우너소의 이전/다음 원소가 존재하지 않는다는 의미)
- unused : 현재 사용되지 않는 인덱스, 즉 새로운 우너소가 들어갈 수 있는 인덱스 👉 원소 추가된 이후 1씩 증가
특별지 0번지는 연결 리스트의 시작 원소로 고정 (= 값이 들어가지 않고 단지 시작점을 나타내기 위한 dummy node)


#### 0x03 연습문제
>Q1. 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때, 해당 List의 길이를 효율적으로 구하는 방법?
>>A1. 동일한 노드가 나올 때까지지 계속 다음 노드로 가면 됨, 공간복잡도 O(1), 시간복잡도 O(N)
<br>

>Q2. 중간에 만나는 두 연결 리스트의 시작점들이 주어졌을 때 만나는 지점을 구하는 방법?
>>A2. 일단 두 시작점 각각에 대해 끝까지 진행시켜서 각각의 길이를 구함.
그 후 다시 두 시작점으로 돌아와서 더 긴 쪽을 둘이 차이만큼 앞으로 먼저 이동시켜놓고, 두 시작점이 만날 때까지 두 시작점을 동시에 한 칸씩 전진시키면 됨. 공간복잡도 O(1), 시간복잡도 O(A+B)
<br>

>Q3. 주어진 연결 리스트 안에 사이클이 있는지 판단하라
>>A3. Floyd’s cycle-finding algorithm, 공간복잡도 O(1), 시간복잡도 O(N)
: 한 칸씩 가는 커서와 두 칸씩 가는 커서를 동일한 시작점에서 출발시키면 사이클이 있는 경우 두 커서는 반드시 만나게 됨. 반대로 만약 사이클이 없으면 두 커서가 만나지 못하고 연결 리스트의 끝에 도달
